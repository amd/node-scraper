import abc
import copy
import datetime
import logging
from typing import Optional, Type

from errorscraper.enums import EventCategory, EventPriority
from errorscraper.models import Event, SystemInfo, TaskResult
from errorscraper.utils import get_subclass

from .taskhook import TaskHook


def get_task_class(
    task_name: str, task_classes: Optional[list[Type["Task"]]] = None
) -> Type["Task"] | None:
    """get a task class given a class name

    Args:
        task_name (str): task name
        task_classes (Optional[list[Type[Task]]], optional): list of all task classes to look through. Defaults to None.

    Returns:
        Type[Task] | None: Task class, None if no class found
    """

    return get_subclass(task_name, Task, task_classes)


class SystemCompatibilityError(Exception):
    """Exception raised when system has invalid attributes for the task"""

    pass


class Task(abc.ABC):  # noqa B204
    """Parent class for all tasks"""

    TASK_TYPE: str

    def __init__(
        self,
        system_info: SystemInfo,
        logger: Optional[logging.Logger] = None,
        max_event_priority_level: EventPriority | str = EventPriority.CRITICAL,
        parent: Optional[str] = None,
        task_hooks: Optional[list[TaskHook]] = None,
        **kwargs,
    ):
        if logger is None:
            logger = logging.getLogger(self.__class__.__name__)
        self.system_info = system_info
        self.logger = logger
        self.max_event_priority_level = max_event_priority_level
        self.parent = parent
        if not task_hooks:
            task_hooks = []
        self.task_hooks = task_hooks
        self.result: TaskResult = self._init_result()

    @property
    def max_event_priority_level(self) -> EventPriority:
        """maximum priority level for events generated by task

        Returns:
            EventPriority: max priority level enum
        """
        return self._max_event_priority_level

    @max_event_priority_level.setter
    def max_event_priority_level(self, input_value: str | EventPriority):
        if isinstance(input_value, str):
            value: EventPriority = getattr(EventPriority, input_value)
        elif isinstance(input_value, EventPriority):
            value: EventPriority = input_value
        else:
            raise ValueError(f"Invalid type for max_event_priority_level: {type(value)}")

        self._max_event_priority_level = value

    def __init_subclass__(cls, **kwargs) -> None:
        super().__init_subclass__(**kwargs)
        if cls.TASK_TYPE is None:
            raise TypeError(f"No value provided for TASK_TYPE in task class {cls.__name__}")

    def _build_event(
        self,
        category: EventCategory | str,
        description: str,
        priority: EventPriority,
        data: Optional[dict] = None,
        timestamp: Optional[datetime.datetime] = None,
    ) -> Event:

        if data is None:
            data = {"task_name": self.__class__.__name__, "task_type": self.TASK_TYPE}

        else:
            data["task_name"] = self.__class__.__name__
            data["task_type"] = self.TASK_TYPE

        if self.parent:
            data["parent"] = self.parent

        if self.system_info.metadata:
            data["system_metadata"] = copy.copy(self.system_info.metadata)

        if priority > self.max_event_priority_level:
            priority = self.max_event_priority_level

        event = Event(
            category=category,
            description=description,
            priority=priority,
            data=data,
        )

        if timestamp:
            event.timestamp = timestamp

        return event

    def _log_event(
        self,
        category: EventCategory | str,
        description: str,
        priority: EventPriority,
        data: Optional[dict] = None,
        timestamp: Optional[datetime.datetime] = None,
        console_log=False,
    ):
        event = self._build_event(
            category=category,
            description=description,
            priority=priority,
            data=data,
            timestamp=timestamp,
        )

        if console_log:
            self.logger.log(getattr(logging, priority.name, logging.INFO), description)

        self.result.events.append(event)

    def _init_result(self):
        result = TaskResult(task=self.__class__.__name__, parent=self.parent)
        return result

    def _run_hooks(self, result, **kwargs):
        for hook in self.task_hooks:
            hook.process_result(result, **kwargs)
